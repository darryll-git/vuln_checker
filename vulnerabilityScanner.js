const fs = require('fs');

const regexPatterns = {
  xss: /<script>.*<\/script>/g,
  sqlInjection: /SELECT .* FROM .* WHERE .*;/g,
  csrf: /<form.*csrf_token.*>/g,
  idor: /\/api\/resource\/\d+/g,
  insecureAuth: /password = '.*';/g,
  commandInjection: /exec\(.*\)/g,
  sensitiveDataExposure: /AWS_ACCESS_KEY_ID = '.*';/g,
  weakPassword: /password = '.*';/g,
  httpProtocol: /http:\/\//g,
  directoryTraversal: /\.\.\//g,
  fileInclusion: /include\(['|"].*['|"]\)/g,
  evalInjection: /eval\(.*\)/g,
  xmlExternalEntity: /<!DOCTYPE.*ENTITY.*>/g,
};

function scanCode(code) {
  const vulnerabilities = [];

  // Helper function to find line numbers
  function findLineNumbers(code, pattern) {
    const lines = code.split('\n');
    const lineNumbers = [];

    for (let i = 0; i < lines.length; i++) {
      if (pattern.test(lines[i])) {
        lineNumbers.push(i + 1); // Add 1 to adjust for zero-based index
      }
    }

    return lineNumbers;
  }

  // Check for XSS vulnerabilities
  const xssLineNumbers = findLineNumbers(code, regexPatterns.xss);
  if (xssLineNumbers.length > 0) {
    vulnerabilities.push({ type: 'XSS', lineNumbers: xssLineNumbers });
  }

  // Check for SQL injection vulnerabilities
  const sqlInjectionLineNumbers = findLineNumbers(code, regexPatterns.sqlInjection);
  if (sqlInjectionLineNumbers.length > 0) {
    vulnerabilities.push({ type: 'SQL Injection', lineNumbers: sqlInjectionLineNumbers });
  }

  // Check for CSRF vulnerabilities
  const csrfLineNumbers = findLineNumbers(code, regexPatterns.csrf);
  if (csrfLineNumbers.length > 0) {
    vulnerabilities.push({ type: 'CSRF', lineNumbers: csrfLineNumbers });
  }

  // Check for IDOR vulnerabilities
  const idorLineNumbers = findLineNumbers(code, regexPatterns.idor);
  if (idorLineNumbers.length > 0) {
    vulnerabilities.push({ type: 'IDOR', lineNumbers: idorLineNumbers });
  }

  // Check for insecure authentication vulnerabilities
  const insecureAuthLineNumbers = findLineNumbers(code, regexPatterns.insecureAuth);
  if (insecureAuthLineNumbers.length > 0) {
    vulnerabilities.push({ type: 'Insecure Authentication', lineNumbers: insecureAuthLineNumbers });
  }

  // Check for command injection vulnerabilities
  const commandInjectionLineNumbers = findLineNumbers(code, regexPatterns.commandInjection);
  if (commandInjectionLineNumbers.length > 0) {
    vulnerabilities.push({ type: 'Command Injection', lineNumbers: commandInjectionLineNumbers });
  }

  // Check for sensitive data exposure vulnerabilities
  const sensitiveDataExposureLineNumbers = findLineNumbers(code, regexPatterns.sensitiveDataExposure);
  if (sensitiveDataExposureLineNumbers.length > 0) {
    vulnerabilities.push({ type: 'Sensitive Data Exposure', lineNumbers: sensitiveDataExposureLineNumbers });
  }

  // Check for weak password patterns
  const weakPasswordLineNumbers = findLineNumbers(code, regexPatterns.weakPassword);
  if (weakPasswordLineNumbers.length > 0) {
    vulnerabilities.push({ type: 'Weak Password Pattern', lineNumbers: weakPasswordLineNumbers });
  }

  // Check for HTTP protocol usage
  const httpProtocolLineNumbers = findLineNumbers(code, regexPatterns.httpProtocol);
  if (httpProtocolLineNumbers.length > 0) {
    vulnerabilities.push({ type: 'HTTP Protocol Usage', lineNumbers: httpProtocolLineNumbers });
  }

  // Check for directory traversal vulnerabilities
  const directoryTraversalLineNumbers = findLineNumbers(code, regexPatterns.directoryTraversal);
  if (directoryTraversalLineNumbers.length > 0) {
    vulnerabilities.push({ type: 'Directory Traversal', lineNumbers: directoryTraversalLineNumbers });
  }

  // Check for file inclusion vulnerabilities
  const fileInclusionLineNumbers = findLineNumbers(code, regexPatterns.fileInclusion);
  if (fileInclusionLineNumbers.length > 0) {
    vulnerabilities.push({ type: 'File Inclusion', lineNumbers: fileInclusionLineNumbers });
  }

  // Check for eval injection vulnerabilities
  const evalInjectionLineNumbers = findLineNumbers(code, regexPatterns.evalInjection);
  if (evalInjectionLineNumbers.length > 0) {
    vulnerabilities.push({ type: 'Eval Injection', lineNumbers: evalInjectionLineNumbers });
  }

  // Check for XML external entity vulnerabilities
  const xmlExternalEntityLineNumbers = findLineNumbers(code, regexPatterns.xmlExternalEntity);
  if (xmlExternalEntityLineNumbers.length > 0) {
    vulnerabilities.push({ type: 'XML External Entity', lineNumbers: xmlExternalEntityLineNumbers });
  }

  return vulnerabilities;
}

// Read the source code from a file or use text content directly
const filePath = 'website_code.txt'; // Replace with the actual file path
fs.readFile(filePath, 'utf8', (err, fileContent) => {
  if (err) {
    console.error('Error reading file:', err);
    return;
  }

  // Pass the file content or text content to scanCode function
  const vulnerabilities = scanCode(fileContent);

  if (vulnerabilities.length === 0) {
    console.log('No vulnerabilities found');
  } else {
    console.log('Vulnerabilities found:');
    vulnerabilities.forEach(vulnerability => {
      console.log(`- ${vulnerability.type}:`);
      console.log(`  - Line numbers: ${vulnerability.lineNumbers.join(', ')}`);
    });
  }
});
